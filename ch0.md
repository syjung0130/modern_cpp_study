## 소개, 용어와 관례

### 이동의미론
 - 오른값(rvalue)에 해당하는 표현식과 왼값(lvalue)에 해당하는 표현식이 구분된다는 점에 근거한다.  
 - 오른값은 이동 연산이 가능한 객체를 가리키지만 왼값은 일반적으로 그렇지 않기 때문이다.  
 개념적으로(실제 응용에서 항상 그렇지는 않지만) 오른값은 함수가 돌려준 임시 객체에 해당하고  
 왼값은 이름이나 포인터, 왼값 참조를 통해서 지칭할 수 있는 객체에 해당한다.  
 - 어떤 한 표현식이 왼값인지 여부를 결정하는데 유용한 발견법(heuristic)은
 그 표현식의 주소를 취할 수 있는지 보는 것이다.  
 일반적으로, 주소를 취할 수 있다면 왼값이고 취할 수 없다면 오른 값이다.  
 
 - 객체를 같은 형식의 다른 객체를 이용해서 초기화할 때, 
 새 객체를 초기화에 쓰인 객체의 복사본이라고 부른다.
 이동생성자를 통해서 생성된 새 객체도 복사본이라고 부른다.
 - C++에는 복사 생성자를 통해 생성된(복사 생성된) 복사본과
 이동 생성자를 통해 생성된(이동 생성된) 복사본을 구분하는 용어가 없다.
 
~~~C++
void someFunc(Widget w); // someFunc의 매개변수 w는 값으로 전달된다.
Widget wid;				// wid는 Widget의 한 객체이다.
someFunc(wid);			// 이 someFunc 호출에서 w는
						// 복사 생성된 wid의
						// 한 복사본이다.
someFunc(std::move(wid)); // 이 someFunc 호출에서 w는
						// 이동 생성된 wid의
						// 한 복사본이다.
~~~
  
 - 대체로 오른 값의 복사본은 이동 생성되고 왼값의 복사본은 복사 생성된다.  
 그래서 한 객체가 다른 객체의 복사본이라는 점만 알고 있다면,  
 그 복사본의 생성 비용이 비쌌는지 아닌지를 알 수 있다.  
 예를 들어, 위의 코드 예제에서 매개변수 w를 만드는데 든 비용이 어느 정도인지 파악하려면  
 someFunc에 전달된 것이 왼값인지 오른 값인지 알아야한다.  
 (또한 Widget의 이동과 복사 비용도 알아야 할 것이다.)

 - 함수 호출의 맥락에서, 호출 지점에서 함수에 전달한 표현식을 인수(argument)라고 부른다.  
 인수는 함수의 매개변수(parameter)를 초기화하는데 쓰인다.  
 위의 첫 someFunc 호출에서 인수는 wid이다. 두번째 호출에서는 std::move(wid)가 인수이다.  
 두 호출 모두 매개변수는 w이다.  
 인수와 매개변수의 구분이 중요한 이유는,  
 매개변수는 왼값이지만 매개변수의 초기화에 쓰이는 인수는 왼값일 수도 있고 오른 값일 수도 있다는 점이다.  
 이 점은 한 함수에 전달된 인수를 그것의 왼 값 또는 오른값 여부를 보존해서 다른 함수에 전달해야하는 완벽 전달 과정에서 특히나 중요하다.  

 ### 함수 객체
 - 함수 객체  
일반적으로 이 책에서 함수 객체(function object)라는 용어는  
operator()멤버 함수를 지원하는 형식의 객체를 뜻한다.  
다른 말로 하면, 함수 객체는 함수처럼 행동하는 객체이다.  
그러나 때에 따라서는 비멤버 함수의 호출 구문, 즉, "함수이름(인수들)" 형태를 이용해서 실행할 수 있는 모든 것을 뜻하는 좀 더 넓은 의미로도 쓰인다.  
이러한 좀 더 넓은 의미의 함수 객체에는 operator()를 지원하는 객체 뿐만 아니라  
보통의 함수와 C 스타일의 함수포인터도 포함된다.  
멤버 함수 포인터를 추가해서 이를 더욱 일반화하면 소위 호출 가능 객체(callable object)가 된다.  
일반적으로는 이러한 세세한 구분을 무시하고, 함수 객체와 호출 가능 객체라는 것이  
그냥 C++에서 일정한 함수 호출 구문을 이용해서 실행할 수 있는 무엇인가라고만 생각해도 무방하다.
  
 - 클로저(closure)  
람다 표현식을 통해 만들어진 함수 객체를 클로저(closure)라고 부른다.  
람다 표현식과 그로부터 생성된 클로저를 굳이 구분해야하는 경우는 드물다.  
그래서 이 책에서는 둘을 그냥 람다(lambda)라고 칭하는 경우가 많다.  

## 선언과 정의
 - 선언  
 C++에는 선언과 정의가 모두 가능한 것들이 많이 있다.  
 선언(declaration)은 이름과 형식을 현재 범위에 도입하기만 하고  
 그 세부사항(저장 장소나 구현 방식 등)은 지정하지 않는 것을 말한다.  
~~~C++
extern int x;	// 객체 선언
class Widget;	// 클래스 선언
bool func(const Widget& w);// 함수 선언
enum class Color;	// 범위 있는 열거형 선언
~~~
 - 정의  
 저장 장소나 구현 세부사항을 지정한다.  
~~~C++
int x;						// 객체 정의
class Widget {				// 클래스 정의
	...
};
bool func(const Widget& w)
{return w.size() < 10;}		// 함수 정의

enum class Color
{ Yellow, Red, Blue };		// 범위 있는 열거형 정의
~~~

## 함수의 서명(signature)에 대한 (이 책에서의)용어 정의
 - 이 책은 함수의 서명(signature)이 함수의 선언 중 매개변수 형식들과 반환 형식을 지정한 부분이라고 정의한다.  
 - 함수 이름과 매개변수 이름은 서명에 포함되지 않는다.  
 - 앞의 예에서 func의 서명은 bool(const Widget&)이다.  
 함수의 선언 중 매개변수 형식과 반환 형식이 아닌 부분은  
 (예를 들어 noexcept나 constexpr이 있다면 그것들도) 서명에 포함되지 않는다.  
 이런 정의는 '서명'의 공식적인 저의와는 조금 다르지만,  
 책의 목적에서는 이 정의가 유용하다.  

## 비권장(deprecate)하는 특정 기능들..
새로운 기능에 비해 열등하거나 좋지 않은 기능들...  
C++11에서 std::auto_ptr은 비권장기능이다. std::unique_ptr이 더 일을 잘 해내기 때문이다.  

## 생(raw) pointer, smart pointer
이 책에서는 new가 돌려주는 포인터 같은 내장 포인터를  
생 포인터라고 부른다.  
생 포인터의 반대는 똑똑한 포인터다.  
대체로 똑똑한 포인터는 포인터 역참조 연산자들(operator->과 operator*)을 중복적재(overloading)하지만,  
항목 20에서 설명하듯이 std::weak_ptr은 예외이다.  

## dtor
소스 코드의 식별자 이름에서 종종 보이는 dtor는 'destructor(소멸자)'를 줄인 것이다.
